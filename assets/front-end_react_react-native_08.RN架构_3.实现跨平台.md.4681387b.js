import{_ as e,o as a,c as t,d as i}from"./chunks/framework.4d89205b.js";const p=JSON.parse('{"title":"3. 实现跨平台","description":"","frontmatter":{},"headers":[],"relativePath":"front-end/react/react-native/08.RN架构/3.实现跨平台.md"}'),o={name:"front-end/react/react-native/08.RN架构/3.实现跨平台.md"},r=[i('<h1 id="_3-实现跨平台" tabindex="-1">3. 实现跨平台 <a class="header-anchor" href="#_3-实现跨平台" aria-label="Permalink to &quot;3. 实现跨平台&quot;">​</a></h1><p>React Native 渲染器利用核心渲染实现跨平台共享。</p><p>在之前的 React Native 渲染系统中，React Shadow Tree、布局逻辑、View Flattening 算法每个平台都实现了一次。 当前的渲染器通过共享核心 C++ 实现从而变为了一个跨平台解决方案。</p><p>React Native 团队打算将动画系统整合到渲染系统中，并将 React Native 渲染系统扩展到 Windows 等新平台，以及游戏机、电视等的操作系统。</p><p>将 C++ 用于核心渲染系统引入了几个优点。 单一实现降低了开发和维护成本。它提高了创建 React Shadow 树和布局计算的性能，因为在 Android 上将 Yoga 与渲染器集成的开销最小化（即，不再有用于 Yoga 的 JNI）。最终，每个 React Shadow Node 在 C++ 中的内存占用比从 Kotlin 或 Swift 分配的要小。</p><blockquote><p>JNI（Java Native Interface）注：用于编写 Java 原生方法的 API，用于在 Fabric 的 C++ 核心和 Android 之间进行通信，用 Java 编写。</p></blockquote><p>该团队还利用了强制不可变性的c++特性，以确保对共享但不受保护的资源的并发访问不会出现问题。</p><p>重要的是要认识到，Android 的渲染器用例仍然会在两个主要用例中产生 JNI 成本：</p><ul><li><p>复杂视图（例如 Text、TextInput 等）的布局计算需要通过 JNI 发送 props。</p></li><li><p>挂载阶段需要通过 JNI 发送修改操作。</p></li></ul><p>该团队正在探索用一种新机制替换 ReadableMap，以使用 ByteBuffer 序列化数据以减少 JNI 的开销。 我们的目标是将 JNI 的开销减少 35-50%。</p><p>渲染器提供了其 C++ API 的两个方面：</p><ul><li><p>(i) 与 React 通信</p></li><li><p>(ii) 与主机平台通信</p></li></ul><p>对于 (i)，React 与渲染器通信以渲染 React 树并“监听”事件（例如 onLayout、onKeyPress、触摸等）。</p><p>对于 (ii)，React Native 渲染器与宿主平台通信以在屏幕上挂载宿主视图（创建、插入、更新或删除宿主视图），并监听用户在宿主平台上生成的事件。</p><p><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2022-07-15-084508.png" alt="image-20220715164507790"></p><p>-<em>EOF</em>-</p>',16)];const n=e(o,[["render",function(e,i,p,o,n,c){return a(),t("div",null,r)}]]);export{p as __pageData,n as default};
